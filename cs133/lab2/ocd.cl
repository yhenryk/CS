const char* ocd = 
"#define a1 (-1.586134342)\n"
"#define a2 (-0.05298011854)\n"
"#define a3 (0.8829110762)\n"
"#define a4 (0.4435068522)\n"
"\n"
"#define k1 1.1496043988602418\n"
"#define k2 (1/1.1496043988602418)\n"
"\n"
"#define x(i, j) x[(i)*M+(j)]\n"
"#define tempbank(i, j) tempbank[(i)*M+(j)]\n"
"\n"
"/**\n"
"* predict and update\n"
"*\n"
"* computation is an even-odd update:\n"
"* first update all odd columns based on even columns, then update even columns based on odd columns\n"
"*/\n"
"void fwt97_pd(\n"
"__global float *x,\n"
"__global float *tempbank,\n"
"int n, int m,\n"
"int N, int M)\n"
"{\n"
"int i, j;\n"
"\n"
"for (i=0; i<n; i++) {\n"
"// Predict 1\n"
"for (j=1; j<m-2; j+=2) {\n"
"x(i, j) += a1*(x(i, j-1) + x(i, j+1));\n"
"}\n"
"x(i, m-1) += 2*a1*x(i, m-2);\n"
"// Update 1\n"
"for (j=2; j<m; j+=2) {\n"
"x(i, j) += a2*(x(i, j-1) + x(i, j+1));\n"
"}\n"
"x(i, 0) += 2*a2*x(i, 1);\n"
"// Predict 2\n"
"for (j=1; j<m-2; j+=2) {\n"
"x(i, j) += a3*(x(i, j-1) + x(i, j+1));\n"
"}\n"
"x(i, m-1) += 2*a3*x(i, m-2);\n"
"\n"
"// Update 2\n"
"for (j=2; j<m; j+=2) {\n"
"x(i, j) += a4*(x(i, j-1) + x(i, j+1));\n"
"}\n"
"x(i, 0) += 2*a4*x(i, 1);\n"
"\n"
"for (j=0; j<m; j++) {\n"
"if (j%2==0)\n"
"tempbank(i, j/2) = k1*x(i, j);\n"
"else\n"
"tempbank(i, j/2+m/2) = k2*x(i, j);\n"
"}\n"
"\n"
"}\n"
"}\n"
"\n"
"/**\n"
"* de-interleave with transpose\n"
"*\n"
"* two different function (foo and bar) are used to move data\n"
"* between x and tempbank\n"
"* the reason for this design is to avoid 'spilling' in x when data\n"
"* is not square (n!=m)\n"
"*\n"
"**/\n"
"void fwt97_dl_foo (\n"
"__global float *x,\n"
"__global float *tempbank,\n"
"int n, int m,\n"
"int N, int M)\n"
"{\n"
"int i, j, ii, jj;\n"
"// de-interleave and transpose\n"
"int tile_size = 8;\n"
"int tile_count = M/tile_size;\n"
"for (i=0; i<n; i+=tile_size) {\n"
"for (j=0; j<m; j+=tile_size) {\n"
"for (ii = 0; ii < tile_size; ii++){\n"
"for (jj = 0; jj < tile_size; jj++){\n"
"int new_i = i + ii;\n"
"int new_j = j + jj;\n"
"tempbank(new_j, new_i) = x(new_i, new_j);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"\n"
"/**\n"
"* CDF9/7 wavelet transform\n"
"*\n"
"* this version assumes a column-based memory layout (Matlab default layout)\n"
"* so the wavelet along columns of the original matrix would be the transform\n"
"* along row in this code.\n"
"*\n"
"* input matrix: nxm (n cols, m rows)\n"
"*\n"
"**/\n"
"void cdf97(\n"
"__global float *x,\n"
"__global float *tempbank,\n"
"int n, int m,\n"
"int level\n"
")\n"
"{\n"
"\n"
"int i;\n"
"int nlevel = (level < 0 ? -level : level);\n"
"\n"
"int N = n;\n"
"int M = m;\n"
"\n"
"int plevel = 1<<nlevel-1;\n"
"\n"
"// this means image is not big enough for transformation\n"
"// which we assume will not happen\n"
"if (N/plevel < 2 || M/plevel < 2)\n"
"return;\n"
"\n"
"if (level > 0) {\n"
"// forward DWT (1. col; 2. row)\n"
"for (i=0; i<nlevel; i++) {\n"
"\n"
"// Stage 1\n"
"fwt97_pd(x, tempbank, m, n, M, N);\n"
"// Stage 2\n"
"fwt97_dl_foo(tempbank, x, m, n, M, N);\n"
"\n"
"// Stage 3\n"
"fwt97_pd(x, tempbank, n, m, n, m);\n"
"\n"
"// Stage 4\n"
"fwt97_dl_foo(tempbank, x, n, m, N, M);\n"
"\n"
"n /= 2;\n"
"m /= 2;\n"
"}\n"
"}\n"
"else {\n"
"// backward DWT, omitted for the project\n"
";\n"
"}\n"
"}\n"
"\n"
"__kernel\n"
"void depth(\n"
"__global float *img,\n"
"__global float *tmp,\n"
"int n, int m,\n"
"int level) {\n"
"const int i = get_global_id(0);\n"
"cdf97(img+i*n*m, tmp+i*n*m, m, n, level);\n"
"\n"
"}\n"
;
